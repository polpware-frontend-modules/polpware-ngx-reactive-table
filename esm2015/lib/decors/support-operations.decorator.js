import { __awaiter } from "tslib";
import { countProperties, defaultInputTypeValue, sliceArray } from '../utils';
export function supportOperationsDecorator(constructor) {
    return class extends constructor {
        get anyEditing() {
            return countProperties(this.backup) > 0;
        }
        onSelect(a) {
            if (a && a.selected && Array.isArray(a.selected)) {
                this.selected = [...a.selected];
            }
        }
        startAdd() {
            const newElem = {
                id: ''
            };
            this.columns.forEach(a => {
                if (a.editable) {
                    newElem[a.prop] = defaultInputTypeValue(a.inputType);
                }
            });
            // Disable sorting
            this.sorts = [];
            // Add the element into the rows (no backup)
            this.datatable.rows = [newElem, ...this.datatable._internalRows];
            this.totalCount = this.totalCount + 1;
            this.backup[0] = newElem;
            // Enable editing it.
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[0 + '-' + a.prop] = true;
                }
            });
        }
        startEdit(rowIndex) {
            // Disable sorts
            this.sorts = [];
            const data = this.datatable._internalRows[rowIndex];
            this.backup[rowIndex] = Object.assign({}, data);
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[rowIndex + '-' + a.prop] = true;
                }
            });
        }
        // Support editing an existing one and adding a new one
        cancelEdit(rowIndex) {
            // Replace the old value
            const firstPart = sliceArray(this.datatable._internalRows, 0, rowIndex - 1);
            const secondPart = sliceArray(this.datatable._internalRows, rowIndex + 1, this.datatable._internalRows.length - 1);
            const elem = this.backup[rowIndex];
            // An existing one
            if (elem.id) {
                this.rows = [...firstPart, elem, ...secondPart];
            }
            else {
                // Otherwise, drop this.
                this.rows = [...firstPart, ...secondPart];
            }
            this.cleanEditing(rowIndex);
            delete this.backup[rowIndex];
        }
        confirmEditAsync(rowIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const elem = this.datatable._internalRows[rowIndex];
                    let newElem = elem;
                    let op = '';
                    if (elem.id) {
                        op = 'update';
                        // Update an existing elment
                        if (this.settings.updateAsyncHandler) {
                            newElem = yield this.settings.updateAsyncHandler(elem);
                        }
                    }
                    else {
                        op = 'create';
                        // Update an existing elment
                        if (this.settings.createAsyncHandler) {
                            newElem = yield this.settings.createAsyncHandler(elem);
                        }
                    }
                    // todo: Do we need to update data ????
                    const firstPart = sliceArray(this.datatable._internalRows, 0, rowIndex - 1);
                    const secondPart = sliceArray(this.datatable._internalRows, rowIndex + 1, this.rows.length - 1);
                    this.rows = [...firstPart, newElem, ...secondPart];
                    this.cleanEditing(rowIndex);
                    delete this.backup[rowIndex];
                    this.publish({
                        op: op,
                        data: newElem,
                        rows: this.rows
                    });
                }
                catch (e) {
                    this.noty.error('Sorry, something went wrong!', 'Operation result');
                }
            });
        }
        updateValue(event, prop, rowIndex) {
            this.datatable._internalRows[rowIndex][prop] = event.target.value;
        }
        cleanEditing(rowIndex) {
            this.columns.forEach(a => {
                if (a.editable) {
                    delete this.editing[rowIndex + '-' + a.prop];
                }
            });
        }
        rmAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this.settings.deleteAsyncHandler) {
                        // Expect to be a transaction 
                        yield this.settings.deleteAsyncHandler(this.selected);
                    }
                    // This operation preserve sorting
                    // Therfore, we on purpose use rows instead of internal rows
                    // Do not refresh; just delete them from the local set.
                    // Update data
                    this.rows = this.rows.filter(a => !this.selected.some(b => b === a));
                    this.totalCount = this.totalCount - this.selected.length;
                    const oldSelected = this.selected;
                    this.selected = [];
                    this.noty.success('Data has been deleted successfully!', 'Operation result');
                    this.publish({
                        op: 'delete',
                        data: oldSelected,
                        rows: this.rows
                    });
                }
                catch (e) {
                    this.noty.error('Sorry, something went wrong!', 'Operation result');
                }
            });
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VwcG9ydC1vcGVyYXRpb25zLmRlY29yYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtcmVhY3RpdmUtdGFibGUvIiwic291cmNlcyI6WyJsaWIvZGVjb3JzL3N1cHBvcnQtb3BlcmF0aW9ucy5kZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBTzlFLE1BQU0sVUFBVSwwQkFBMEIsQ0FBa0UsV0FBYztJQUN0SCxPQUFPLEtBQU0sU0FBUSxXQUFXO1FBRTVCLElBQUksVUFBVTtZQUNWLE9BQU8sZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVELFFBQVEsQ0FBQyxDQUF5QjtZQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUM5QyxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDbkM7UUFDTCxDQUFDO1FBRUQsUUFBUTtZQUNKLE1BQU0sT0FBTyxHQUFRO2dCQUNqQixFQUFFLEVBQUUsRUFBRTthQUNULENBQUM7WUFDRixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDckIsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFO29CQUNaLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUN4RDtZQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0gsa0JBQWtCO1lBQ2xCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1lBQ2hCLDRDQUE0QztZQUM1QyxJQUFJLENBQUMs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QUFFLEVBQUUsUUFBUTt3QkFDWixJQUFJLEVBQUUsV0FBVzt3QkFDakIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO3FCQUNsQixDQUFDLENBQUM7aUJBQ047Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1IsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsOEJBQThCLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztpQkFDdkU7WUFDTCxDQUFDO1NBQUE7S0FFSixDQUFBO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSb3dEYXRhVHlwZSwgSVRhYmxlV2l0aE9wZXJhdGlvbnNCYXNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IGNvdW50UHJvcGVydGllcywgZGVmYXVsdElucHV0VHlwZVZhbHVlLCBzbGljZUFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW50ZXJmYWNlIElEZWNvcmF0b3JQcmVyZXF1aXNpdGU8VCBleHRlbmRzIElSb3dEYXRhVHlwZT4gZXh0ZW5kcyBJVGFibGVXaXRoT3BlcmF0aW9uc0Jhc2U8VD4ge1xyXG59XHJcblxyXG50eXBlIERlY29yYXRvclByZXJlcXVpc2l0ZUNsYXNzPFQgZXh0ZW5kcyBJUm93RGF0YVR5cGU+ID0geyBuZXcoLi4uYXJnczogYW55W10pOiBJRGVjb3JhdG9yUHJlcmVxdWlzaXRlPFQ+IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydE9wZXJhdGlvbnNEZWNvcmF0b3I8VCBleHRlbmRzIElSb3dEYXRhVHlwZSwgVSBleHRlbmRzIERlY29yYXRvclByZXJlcXVpc2l0ZUNsYXNzPFQ+Pihjb25zdHJ1Y3RvcjogVSkge1xyXG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgaW1wbGVtZW50cyBJVGFibGVXaXRoT3BlcmF0aW9uc0Jhc2U8VD4ge1xyXG5cclxuICAgICAgICBnZXQgYW55RWRpdGluZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50UHJvcGVydGllcyh0aGlzLmJhY2t1cCkgPiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb25TZWxlY3QoYTogeyBzZWxlY3RlZDogQXJyYXk8VD4gfSkge1xyXG4gICAgICAgICAgICBpZiAoYSAmJiBhLnNlbGVjdGVkICYmIEFycmF5LmlzQXJyYXkoYS5zZWxlY3RlZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBbLi4uYS5zZWxlY3RlZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0QWRkKCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtOiBhbnkgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogJydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1bYS5wcm9wXSA9IGRlZmF1bHRJbnB1dFR5cGVWYWx1ZShhLmlucHV0VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBEaXNhYmxlIHNvcnRpbmdcclxuICAgICAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGVsZW1lbnQgaW50byB0aGUgcm93cyAobm8gYmFja3VwKVxyXG4gICAgICAgICAgICB0aGlzLmRhdGF0YWJsZS5yb3dzID0gW25ld0VsZW0sIC4uLnRoaXMuZGF0YXRhYmxlLl9pbnRlcm5hbFJvd3NdO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSB0aGlzLnRvdGFsQ291bnQgKyAxO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cFswXSA9IG5ld0VsZW07XHJcbiAgICAgICAgICAgIC8vIEVuYWJsZSBlZGl0aW5nIGl0LlxyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0aW5nWzAgKyAnLScgKyBhLnByb3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFydEVkaXQocm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICAvLyBEaXNhYmxlIHNvcnRzXHJcbiAgICAgICAgICAgIHRoaXMuc29ydHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YXRhYmxlLl9pbnRlcm5hbFJvd3Nbcm93SW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cFtyb3dJbmRleF0gPSB7IC4uLmRhdGEgfTtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGluZ1tyb3dJbmRleCArICctJyArIGEucHJvcF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQgZWRpdGluZyBhbiBleGlzdGluZyBvbmUgYW5kIGFkZGluZyBhIG5ldyBvbmVcclxuICAgICAgICBjYW5jZWxFZGl0KHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgb2xkIHZhbHVlXHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHNsaWNlQXJyYXkodGhpcy5kYXRhdGFibGUuX2ludGVybmFsUm93cywgMCwgcm93SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IHNsaWNlQXJyYXkodGhpcy5kYXRhdGFibGUuX2ludGVybmFsUm93cywgcm93SW5kZXggKyAxLCB0aGlzLmRhdGF0YWJsZS5faW50ZXJuYWxSb3dzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5iYWNrdXBbcm93SW5kZXhdO1xyXG4gICAgICAgICAgICAvLyBBbiBleGlzdGluZyBvbmVcclxuICAgICAgICAgICAgaWYgKGVsZW0uaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IFsuLi5maXJzdFBhcnQsIGVsZW0sIC4uLnNlY29uZFBhcnRdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcm9wIHRoaXMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSBbLi4uZmlyc3RQYXJ0LCAuLi5zZWNvbmRQYXJ0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFuRWRpdGluZyhyb3dJbmRleCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJhY2t1cFtyb3dJbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgYXN5bmMgY29uZmlybUVkaXRBc3luYyhyb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5kYXRhdGFibGUuX2ludGVybmFsUm93c1tyb3dJbmRleF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RWxlbTogSVJvd0RhdGFUeXBlID0gZWxlbTtcclxuICAgICAgICAgICAgICAgIGxldCBvcDogJ2NyZWF0ZScgfCAndXBkYXRlJyB8ICcnID0gJyc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wID0gJ3VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIGVsbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnVwZGF0ZUFzeW5jSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFbGVtID0gYXdhaXQgdGhpcy5zZXR0aW5ncy51cGRhdGVBc3luY0hhbmRsZXIoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcCA9ICdjcmVhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbiBleGlzdGluZyBlbG1lbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jcmVhdGVBc3luY0hhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RWxlbSA9IGF3YWl0IHRoaXMuc2V0dGluZ3MuY3JlYXRlQXN5bmNIYW5kbGVyKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBEbyB3ZSBuZWVkIHRvIHVwZGF0ZSBkYXRhID8/Pz9cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHNsaWNlQXJyYXkodGhpcy5kYXRhdGFibGUuX2ludGVybmFsUm93cywgMCwgcm93SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhcnQgPSBzbGljZUFycmF5KHRoaXMuZGF0YXRhYmxlLl9pbnRlcm5hbFJvd3MsIHJvd0luZGV4ICsgMSwgdGhpcy5yb3dzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gWy4uLmZpcnN0UGFydCwgbmV3RWxlbSwgLi4uc2Vjb25kUGFydF07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbkVkaXRpbmcocm93SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmFja3VwW3Jvd0luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wOiBvcCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBuZXdFbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm90eS5lcnJvcignU29ycnksIHNvbWV0aGluZyB3ZW50IHdyb25nIScsICdPcGVyYXRpb24gcmVzdWx0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZVZhbHVlKGV2ZW50OiBhbnksIHByb3A6IHN0cmluZywgcm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGF0YWJsZS5faW50ZXJuYWxSb3dzW3Jvd0luZGV4XVtwcm9wXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsZWFuRWRpdGluZyhyb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEuZWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5lZGl0aW5nW3Jvd0luZGV4ICsgJy0nICsgYS5wcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3luYyBybUFzeW5jKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVsZXRlQXN5bmNIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwZWN0IHRvIGJlIGEgdHJhbnNhY3Rpb24gXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR0aW5ncy5kZWxldGVBc3luY0hhbmRsZXIodGhpcy5zZWxlY3RlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9wZXJhdGlvbiBwcmVzZXJ2ZSBzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZm9yZSwgd2Ugb24gcHVycG9zZSB1c2Ugcm93cyBpbnN0ZWFkIG9mIGludGVybmFsIHJvd3NcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgcmVmcmVzaDsganVzdCBkZWxldGUgdGhlbSBmcm9tIHRoZSBsb2NhbCBzZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLmZpbHRlcihhID0+ICF0aGlzLnNlbGVjdGVkLnNvbWUoYiA9PiBiID09PSBhKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSB0aGlzLnRvdGFsQ291bnQgLSB0aGlzLnNlbGVjdGVkLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3R5LnN1Y2Nlc3MoJ0RhdGEgaGFzIGJlZW4gZGVsZXRlZCBzdWNjZXNzZnVsbHkhJywgJ09wZXJhdGlvbiByZXN1bHQnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdkZWxldGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9sZFNlbGVjdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm90eS5lcnJvcignU29ycnksIHNvbWV0aGluZyB3ZW50IHdyb25nIScsICdPcGVyYXRpb24gcmVzdWx0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcbiJdfQ==