import { __awaiter } from "tslib";
import { countProperties, defaultInputTypeValue, sliceArray } from '../utils';
export function supportOperationsDecorator(constructor) {
    return class extends constructor {
        get anyEditing() {
            return countProperties(this.backup) > 0;
        }
        onSelect({ selected }) {
            this.selected.splice(0, this.selected.length);
            this.selected.push(...selected);
        }
        startAdd() {
            const newElem = {
                id: ''
            };
            this.columns.forEach(a => {
                if (a.editable) {
                    newElem[a.prop] = defaultInputTypeValue(a.inputType);
                }
            });
            // Add the element into the rows (no backup)
            this.rows = [newElem, ...this.rows];
            this.totalCount = this.totalCount + 1;
            this.backup[0] = newElem;
            // Enable editing it.
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[0 + '-' + a.prop] = true;
                }
            });
        }
        startEdit(rowIndex) {
            const data = this.rows[rowIndex];
            this.backup[rowIndex] = Object.assign({}, data);
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[rowIndex + '-' + a.prop] = true;
                }
            });
        }
        // Support editing an existing one and adding a new one
        cancelEdit(rowIndex) {
            // Replace the old value
            const firstPart = sliceArray(this.rows, 0, rowIndex - 1);
            const secondPart = sliceArray(this.rows, rowIndex + 1, this.rows.length - 1);
            const elem = this.backup[rowIndex];
            // An existing one
            if (elem.id) {
                this.rows = [...firstPart, elem, ...secondPart];
            }
            else {
                // Otherwise, drop this.
                this.rows = [...firstPart, ...secondPart];
            }
            this.cleanEditing(rowIndex);
            delete this.backup[rowIndex];
        }
        confirmEditAsync(rowIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const elem = this.rows[rowIndex];
                    let newElem = null;
                    if (this.settings.addOrEditAsyncHandler) {
                        newElem = yield this.settings.addOrEditAsyncHandler(elem);
                        // todo: Do we need to update data ????
                        const firstPart = sliceArray(this.rows, 0, rowIndex - 1);
                        const secondPart = sliceArray(this.rows, rowIndex + 1, this.rows.length - 1);
                        this.rows = [...firstPart, newElem, ...secondPart];
                    }
                    this.cleanEditing(rowIndex);
                    delete this.backup[rowIndex];
                    this.dataChange.emit({
                        op: 'addOrEdit',
                        data: newElem,
                        rows: this.rows
                    });
                }
                catch (e) {
                    this.noty.error('Sorry, something went wrong!', 'Operation result');
                }
            });
        }
        updateValue(event, prop, rowIndex) {
            this.rows[rowIndex][prop] = event.target.value;
        }
        cleanEditing(rowIndex) {
            this.columns.forEach(a => {
                if (a.editable) {
                    delete this.editing[rowIndex + '-' + a.prop];
                }
            });
        }
        rmAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    if (this.settings.rmAsyncHandler) {
                        // Expect to be a transaction 
                        yield this.settings.rmAsyncHandler(this.selected);
                    }
                    // Do not refresh; just delete them from the local set.
                    // Update data
                    this.rows = this.rows.filter(a => !this.selected.some(b => b === a));
                    this.totalCount = this.totalCount - this.selected.length;
                    const oldSelected = this.selected;
                    this.selected = [];
                    this.noty.success('Data has been deleted successfully!', 'Operation result');
                    this.dataChange.emit({
                        op: 'rm',
                        data: oldSelected,
                        rows: this.rows
                    });
                }
                catch (e) {
                    this.noty.error('Sorry, something went wrong!', 'Operation result');
                }
            });
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VwcG9ydC1vcGVyYXRpb25zLmRlY29yYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtcmVhY3RpdmUtdGFibGUvIiwic291cmNlcyI6WyJsaWIvZGVjb3JzL3N1cHBvcnQtb3BlcmF0aW9ucy5kZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBTzlFLE1BQU0sVUFBVSwwQkFBMEIsQ0FBa0UsV0FBYztJQUN0SCxPQUFPLEtBQU0sU0FBUSxXQUFXO1FBRTVCLElBQUksVUFBVTtZQUNWLE9BQU8sZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVELFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFFRCxRQUFRO1lBQ0osTUFBTSxPQUFPLEdBQVE7Z0JBQ2pCLEVBQUUsRUFBRSxFQUFFO2FBQ1QsQ0FBQztZQUNGLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyQixJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0JBQ1osT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQ3hEO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFDSCw0Q0FBNEM7WUFDNUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZ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RyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDckUsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO29CQUV6RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO29CQUNsQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztvQkFFbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMscUNBQXFDLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztvQkFDN0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7d0JBQ2pCLEVBQUUsRUFBRSxJQUFJO3dCQUNSLElBQUksRUFBRSxXQUFXO3dCQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7cUJBQ2xCLENBQUMsQ0FBQztpQkFDTjtnQkFBQyxPQUFPLENBQUMsRUFBRTtvQkFDUixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyw4QkFBOEIsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2lCQUN2RTtZQUNMLENBQUM7U0FBQTtLQUVKLENBQUE7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVJvd0RhdGFUeXBlLCBJVGFibGVXaXRoT3BlcmF0aW9uc0Jhc2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgY291bnRQcm9wZXJ0aWVzLCBkZWZhdWx0SW5wdXRUeXBlVmFsdWUsIHNsaWNlQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XHJcblxyXG5pbnRlcmZhY2UgSURlY29yYXRvclByZXJlcXVpc2l0ZTxUIGV4dGVuZHMgSVJvd0RhdGFUeXBlPiBleHRlbmRzIElUYWJsZVdpdGhPcGVyYXRpb25zQmFzZTxUPiB7XHJcbn1cclxuXHJcbnR5cGUgRGVjb3JhdG9yUHJlcmVxdWlzaXRlQ2xhc3M8VCBleHRlbmRzIElSb3dEYXRhVHlwZT4gPSB7IG5ldyguLi5hcmdzOiBhbnlbXSk6IElEZWNvcmF0b3JQcmVyZXF1aXNpdGU8VD4gfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0T3BlcmF0aW9uc0RlY29yYXRvcjxUIGV4dGVuZHMgSVJvd0RhdGFUeXBlLCBVIGV4dGVuZHMgRGVjb3JhdG9yUHJlcmVxdWlzaXRlQ2xhc3M8VD4+KGNvbnN0cnVjdG9yOiBVKSB7XHJcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBjb25zdHJ1Y3RvciBpbXBsZW1lbnRzIElUYWJsZVdpdGhPcGVyYXRpb25zQmFzZTxUPiB7XHJcblxyXG4gICAgICAgIGdldCBhbnlFZGl0aW5nKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY291bnRQcm9wZXJ0aWVzKHRoaXMuYmFja3VwKSA+IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvblNlbGVjdCh7IHNlbGVjdGVkIH0pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5zcGxpY2UoMCwgdGhpcy5zZWxlY3RlZC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLnB1c2goLi4uc2VsZWN0ZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnRBZGQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0VsZW06IGFueSA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiAnJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RWxlbVthLnByb3BdID0gZGVmYXVsdElucHV0VHlwZVZhbHVlKGEuaW5wdXRUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgZWxlbWVudCBpbnRvIHRoZSByb3dzIChubyBiYWNrdXApXHJcbiAgICAgICAgICAgIHRoaXMucm93cyA9IFtuZXdFbGVtLCAuLi50aGlzLnJvd3NdO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSB0aGlzLnRvdGFsQ291bnQgKyAxO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2t1cFswXSA9IG5ld0VsZW07XHJcbiAgICAgICAgICAgIC8vIEVuYWJsZSBlZGl0aW5nIGl0LlxyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0aW5nWzAgKyAnLScgKyBhLnByb3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFydEVkaXQocm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yb3dzW3Jvd0luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrdXBbcm93SW5kZXhdID0geyAuLi5kYXRhIH07XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEuZWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRpbmdbcm93SW5kZXggKyAnLScgKyBhLnByb3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0IGVkaXRpbmcgYW4gZXhpc3Rpbmcgb25lIGFuZCBhZGRpbmcgYSBuZXcgb25lXHJcbiAgICAgICAgY2FuY2VsRWRpdChyb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIG9sZCB2YWx1ZVxyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBzbGljZUFycmF5KHRoaXMucm93cywgMCwgcm93SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IHNsaWNlQXJyYXkodGhpcy5yb3dzLCByb3dJbmRleCArIDEsIHRoaXMucm93cy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMuYmFja3VwW3Jvd0luZGV4XTtcclxuICAgICAgICAgICAgLy8gQW4gZXhpc3Rpbmcgb25lXHJcbiAgICAgICAgICAgIGlmIChlbGVtLmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSBbLi4uZmlyc3RQYXJ0LCBlbGVtLCAuLi5zZWNvbmRQYXJ0XTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZHJvcCB0aGlzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gWy4uLmZpcnN0UGFydCwgLi4uc2Vjb25kUGFydF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jbGVhbkVkaXRpbmcocm93SW5kZXgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5iYWNrdXBbcm93SW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGFzeW5jIGNvbmZpcm1FZGl0QXN5bmMocm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMucm93c1tyb3dJbmRleF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RWxlbTogSVJvd0RhdGFUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFkZE9yRWRpdEFzeW5jSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW0gPSBhd2FpdCB0aGlzLnNldHRpbmdzLmFkZE9yRWRpdEFzeW5jSGFuZGxlcihlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0b2RvOiBEbyB3ZSBuZWVkIHRvIHVwZGF0ZSBkYXRhID8/Pz9cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBzbGljZUFycmF5KHRoaXMucm93cywgMCwgcm93SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gc2xpY2VBcnJheSh0aGlzLnJvd3MsIHJvd0luZGV4ICsgMSwgdGhpcy5yb3dzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IFsuLi5maXJzdFBhcnQsIG5ld0VsZW0sIC4uLnNlY29uZFBhcnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbkVkaXRpbmcocm93SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmFja3VwW3Jvd0luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2UuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdhZGRPckVkaXQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5ld0VsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcm93czogdGhpcy5yb3dzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3R5LmVycm9yKCdTb3JyeSwgc29tZXRoaW5nIHdlbnQgd3JvbmchJywgJ09wZXJhdGlvbiByZXN1bHQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBkYXRlVmFsdWUoZXZlbnQ6IGFueSwgcHJvcDogc3RyaW5nLCByb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93c1tyb3dJbmRleF1bcHJvcF0gPSBldmVudC50YXJnZXQudmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjbGVhbkVkaXRpbmcocm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWRpdGluZ1tyb3dJbmRleCArICctJyArIGEucHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXN5bmMgcm1Bc3luYygpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJtQXN5bmNIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwZWN0IHRvIGJlIGEgdHJhbnNhY3Rpb24gXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXR0aW5ncy5ybUFzeW5jSGFuZGxlcih0aGlzLnNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCByZWZyZXNoOyBqdXN0IGRlbGV0ZSB0aGVtIGZyb20gdGhlIGxvY2FsIHNldC5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBkYXRhXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MuZmlsdGVyKGEgPT4gIXRoaXMuc2VsZWN0ZWQuc29tZShiID0+IGIgPT09IGEpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudG90YWxDb3VudCA9IHRoaXMudG90YWxDb3VudCAtIHRoaXMuc2VsZWN0ZWQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vdHkuc3VjY2VzcygnRGF0YSBoYXMgYmVlbiBkZWxldGVkIHN1Y2Nlc3NmdWxseSEnLCAnT3BlcmF0aW9uIHJlc3VsdCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wOiAncm0nLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9sZFNlbGVjdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93c1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm90eS5lcnJvcignU29ycnksIHNvbWV0aGluZyB3ZW50IHdyb25nIScsICdPcGVyYXRpb24gcmVzdWx0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcbiJdfQ==