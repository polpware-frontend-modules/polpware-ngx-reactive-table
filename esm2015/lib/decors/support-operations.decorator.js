import { __awaiter } from "tslib";
import { countProperties, defaultInputTypeValue, sliceArray } from '../utils';
export function supportOperationsDecorator(constructor) {
    return class extends constructor {
        get anyEditing() {
            return countProperties(this.backup) > 0;
        }
        onSelect({ selected }) {
            this.selected.splice(0, this.selected.length);
            this.selected.push(...selected);
        }
        startAdd() {
            const newElem = {
                id: ''
            };
            this.columns.forEach(a => {
                if (a.editable) {
                    newElem[a.prop] = defaultInputTypeValue(a.inputType);
                }
            });
            // Add the element into the rows (no backup)
            this.rows = [newElem, ...this.rows];
            this.totalCount = this.totalCount + 1;
            this.backup[0] = newElem;
            // Enable editing it.
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[0 + '-' + a.prop] = true;
                }
            });
        }
        startEdit(rowIndex) {
            const data = this.rows[rowIndex];
            this.backup[rowIndex] = Object.assign({}, data);
            this.columns.forEach(a => {
                if (a.editable) {
                    this.editing[rowIndex + '-' + a.prop] = true;
                }
            });
        }
        // Support editing an existing one and adding a new one
        cancelEdit(rowIndex) {
            // Replace the old value
            const firstPart = sliceArray(this.rows, 0, rowIndex - 1);
            const secondPart = sliceArray(this.rows, rowIndex + 1, this.rows.length - 1);
            const elem = this.backup[rowIndex];
            // An existing one
            if (elem.id) {
                this.rows = [...firstPart, elem, ...secondPart];
            }
            else {
                // Otherwise, drop this.
                this.rows = [...firstPart, ...secondPart];
            }
            this.cleanEditing(rowIndex);
            delete this.backup[rowIndex];
        }
        confirmEditAsync(rowIndex) {
            return __awaiter(this, void 0, void 0, function* () {
                const elem = this.rows[rowIndex];
                if (this.settings.addOrEditAsyncHandler) {
                    const newElem = yield this.settings.addOrEditAsyncHandler(elem);
                    // todo: Do we need to update data ????
                    const firstPart = sliceArray(this.rows, 0, rowIndex - 1);
                    const secondPart = sliceArray(this.rows, rowIndex + 1, this.rows.length - 1);
                    this.rows = [...firstPart, newElem, ...secondPart];
                }
                this.cleanEditing(rowIndex);
                delete this.backup[rowIndex];
            });
        }
        updateValue(event, prop, rowIndex) {
            this.rows[rowIndex][prop] = event.target.value;
        }
        cleanEditing(rowIndex) {
            this.columns.forEach(a => {
                if (a.editable) {
                    delete this.editing[rowIndex + '-' + a.prop];
                }
            });
        }
        rmAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.settings.rmAsyncHandler) {
                    // Expect to be a transaction 
                    yield this.settings.rmAsyncHandler(this.selected);
                }
                // Do not refresh; just delete them from the local set.
                // Update data
                this.rows = this.rows.filter(a => !this.selected.some(b => b === a));
                this.totalCount = this.totalCount - this.selected.length;
                this.selected = [];
            });
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VwcG9ydC1vcGVyYXRpb25zLmRlY29yYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtcmVhY3RpdmUtdGFibGUvIiwic291cmNlcyI6WyJsaWIvZGVjb3JzL3N1cHBvcnQtb3BlcmF0aW9ucy5kZWNvcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBTzlFLE1BQU0sVUFBVSwwQkFBMEIsQ0FBa0UsV0FBYztJQUN0SCxPQUFPLEtBQU0sU0FBUSxXQUFXO1FBRTVCLElBQUksVUFBVTtZQUNWLE9BQU8sZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUVELFFBQVEsQ0FBQyxFQUFFLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFFRCxRQUFRO1lBQ0osTUFBTSxPQUFPLEdBQVE7Z0JBQ2pCLEVBQUUsRUFBRSxFQUFFO2FBQ1QsQ0FBQztZQUNGLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyQixJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7b0JBQ1osT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7aUJBQ3hEO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFDSCw0Q0FBNEM7WUFDNUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZ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O0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElSb3dEYXRhVHlwZSwgSVRhYmxlV2l0aE9wZXJhdGlvbnNCYXNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IGNvdW50UHJvcGVydGllcywgZGVmYXVsdElucHV0VHlwZVZhbHVlLCBzbGljZUFycmF5IH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW50ZXJmYWNlIElEZWNvcmF0b3JQcmVyZXF1aXNpdGU8VCBleHRlbmRzIElSb3dEYXRhVHlwZT4gZXh0ZW5kcyBJVGFibGVXaXRoT3BlcmF0aW9uc0Jhc2U8VD4ge1xyXG59XHJcblxyXG50eXBlIERlY29yYXRvclByZXJlcXVpc2l0ZUNsYXNzPFQgZXh0ZW5kcyBJUm93RGF0YVR5cGU+ID0geyBuZXcoLi4uYXJnczogYW55W10pOiBJRGVjb3JhdG9yUHJlcmVxdWlzaXRlPFQ+IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydE9wZXJhdGlvbnNEZWNvcmF0b3I8VCBleHRlbmRzIElSb3dEYXRhVHlwZSwgVSBleHRlbmRzIERlY29yYXRvclByZXJlcXVpc2l0ZUNsYXNzPFQ+Pihjb25zdHJ1Y3RvcjogVSkge1xyXG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgY29uc3RydWN0b3IgaW1wbGVtZW50cyBJVGFibGVXaXRoT3BlcmF0aW9uc0Jhc2U8VD4ge1xyXG5cclxuICAgICAgICBnZXQgYW55RWRpdGluZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50UHJvcGVydGllcyh0aGlzLmJhY2t1cCkgPiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb25TZWxlY3QoeyBzZWxlY3RlZCB9KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc3BsaWNlKDAsIHRoaXMuc2VsZWN0ZWQubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZC5wdXNoKC4uLnNlbGVjdGVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0QWRkKCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdFbGVtOiBhbnkgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogJydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VsZW1bYS5wcm9wXSA9IGRlZmF1bHRJbnB1dFR5cGVWYWx1ZShhLmlucHV0VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGVsZW1lbnQgaW50byB0aGUgcm93cyAobm8gYmFja3VwKVxyXG4gICAgICAgICAgICB0aGlzLnJvd3MgPSBbbmV3RWxlbSwgLi4udGhpcy5yb3dzXTtcclxuICAgICAgICAgICAgdGhpcy50b3RhbENvdW50ID0gdGhpcy50b3RhbENvdW50ICsgMTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrdXBbMF0gPSBuZXdFbGVtO1xyXG4gICAgICAgICAgICAvLyBFbmFibGUgZWRpdGluZyBpdC5cclxuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goYSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYS5lZGl0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdGluZ1swICsgJy0nICsgYS5wcm9wXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhcnRFZGl0KHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMucm93c1tyb3dJbmRleF07XHJcbiAgICAgICAgICAgIHRoaXMuYmFja3VwW3Jvd0luZGV4XSA9IHsgLi4uZGF0YSB9O1xyXG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChhID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0aW5nW3Jvd0luZGV4ICsgJy0nICsgYS5wcm9wXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydCBlZGl0aW5nIGFuIGV4aXN0aW5nIG9uZSBhbmQgYWRkaW5nIGEgbmV3IG9uZVxyXG4gICAgICAgIGNhbmNlbEVkaXQocm93SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBvbGQgdmFsdWVcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gc2xpY2VBcnJheSh0aGlzLnJvd3MsIDAsIHJvd0luZGV4IC0gMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhcnQgPSBzbGljZUFycmF5KHRoaXMucm93cywgcm93SW5kZXggKyAxLCB0aGlzLnJvd3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmJhY2t1cFtyb3dJbmRleF07XHJcbiAgICAgICAgICAgIC8vIEFuIGV4aXN0aW5nIG9uZVxyXG4gICAgICAgICAgICBpZiAoZWxlbS5pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gWy4uLmZpcnN0UGFydCwgZWxlbSwgLi4uc2Vjb25kUGFydF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRyb3AgdGhpcy5cclxuICAgICAgICAgICAgICAgIHRoaXMucm93cyA9IFsuLi5maXJzdFBhcnQsIC4uLnNlY29uZFBhcnRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYW5FZGl0aW5nKHJvd0luZGV4KTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmFja3VwW3Jvd0luZGV4XTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBhc3luYyBjb25maXJtRWRpdEFzeW5jKHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMucm93c1tyb3dJbmRleF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFkZE9yRWRpdEFzeW5jSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWxlbSA9IGF3YWl0IHRoaXMuc2V0dGluZ3MuYWRkT3JFZGl0QXN5bmNIYW5kbGVyKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogRG8gd2UgbmVlZCB0byB1cGRhdGUgZGF0YSA/Pz8/XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBzbGljZUFycmF5KHRoaXMucm93cywgMCwgcm93SW5kZXggLSAxKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZFBhcnQgPSBzbGljZUFycmF5KHRoaXMucm93cywgcm93SW5kZXggKyAxLCB0aGlzLnJvd3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MgPSBbLi4uZmlyc3RQYXJ0LCBuZXdFbGVtLCAuLi5zZWNvbmRQYXJ0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNsZWFuRWRpdGluZyhyb3dJbmRleCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJhY2t1cFtyb3dJbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1cGRhdGVWYWx1ZShldmVudDogYW55LCBwcm9wOiBzdHJpbmcsIHJvd0luZGV4OiBudW1iZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dzW3Jvd0luZGV4XVtwcm9wXSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsZWFuRWRpdGluZyhyb3dJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEuZWRpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5lZGl0aW5nW3Jvd0luZGV4ICsgJy0nICsgYS5wcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhc3luYyBybUFzeW5jKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5ybUFzeW5jSGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwZWN0IHRvIGJlIGEgdHJhbnNhY3Rpb24gXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldHRpbmdzLnJtQXN5bmNIYW5kbGVyKHRoaXMuc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCByZWZyZXNoOyBqdXN0IGRlbGV0ZSB0aGVtIGZyb20gdGhlIGxvY2FsIHNldC5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGRhdGFcclxuICAgICAgICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzLmZpbHRlcihhID0+ICF0aGlzLnNlbGVjdGVkLnNvbWUoYiA9PiBiID09PSBhKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxDb3VudCA9IHRoaXMudG90YWxDb3VudCAtIHRoaXMuc2VsZWN0ZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG4iXX0=